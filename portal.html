<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Portal Runner – PT by PixelPlay (Refactor)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
  <style>
    :root {
      --bg: #181818;
      --panel: #222;
      --accent: #ff9800;
      --accent-2: #00e5ff; /* cyan for teleport */
      --accent-3: #b455ff; /* purple for score portal */
      --white: #ffffff;
      --text-dim: #d7d7d7;
      --shadow: 0 2px 16px #000a;
    }

    html, body { height: 100%; }
    body {
      background: var(--bg);
      color: var(--white);
      font-family: ui-monospace, Menlo, Monaco, "Cascadia Mono", Consolas, "Courier New", monospace;
      margin: 0;
      display: grid;
      place-items: center;
    }

    /* Centered container */
    .game-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: min(95vw, 860px);
      margin: 24px auto;
    }

    #main-logo {
      font-size: 2.1rem;
      letter-spacing: 2px;
      margin: 16px 0 10px 0;
      animation: breathe 2.4s ease-in-out infinite;
      text-shadow: 0 0 8px #000;
    }
    #main-logo span { color: var(--accent); }

    @keyframes breathe {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.06); opacity: .9; }
      100% { transform: scale(1); opacity: 1; }
    }

    .stage {
      position: relative;
      width: 100%;
      display: grid;
      place-items: center;
    }

    canvas {
      background: var(--panel);
      image-rendering: pixelated;
      border-radius: 12px;
      width: 100%;            /* responsive scale */
      height: auto;           /* keep aspect ratio */
      max-width: 720px;       /* upscale cap */
      box-shadow: var(--shadow);
    }

    /* Floating menu button */
    #floating-menu-btn {
      width: 36px; height: 36px;
      background: var(--accent);
      border: 3px solid var(--white);
      border-radius: 8px;
      margin: 14px auto 0 auto;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 8px #0006;
      font-size: 18px;
      transition: background 0.2s, transform .05s;
      position: relative;
      user-select: none;
    }
    #floating-menu-btn:active { transform: translateY(1px); }
    #floating-menu-btn .pixel-dot {
      width: 12px; height: 12px;
      background: var(--white);
      border-radius: 2px;
      box-shadow: 0 0 0 2px var(--accent);
    }

    /* Floating menu panel */
    #floating-menu {
      display: none;
      position: relative;
      margin-top: 8px;
      background: var(--panel);
      border: 2px solid var(--accent);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 12px 16px;
      z-index: 20;
      min-width: 260px;
      text-align: center;
      animation: fadeIn 0.2s;
    }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }

    .menu-btn {
      background: var(--accent);
      color: var(--white);
      border: 2px solid var(--white);
      border-radius: 10px;
      font-size: 1.1rem;
      margin: 6px 6px;
      padding: 10px 14px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s, transform .05s;
      box-shadow: 0 2px 8px #0004;
      display: inline-flex; align-items: center; justify-content: center;
    }
    .menu-btn:hover { background: #ffa726; color: #222; }
    .menu-btn:active { transform: translateY(1px); }
    .menu-btn i { margin-right: 6px; }

    /* UI overlay (score + highscore + track) */
    #ui {
      pointer-events: none;
      position: absolute; inset: 0;
      display: flex; flex-direction: column; align-items: flex-end;
      padding: 6px; gap: 6px;
    }
    #score, #highscore {
      color: var(--accent);
      font-size: .95rem;
      text-shadow: 1px 1px 2px #000c;
      margin-right: 10px;
    }

    /* Track ticker (lower-left) */
    #track-info {
      position: absolute; left: 10px; bottom: 8px; right: 10px;
      text-align: left;
      color: var(--text-dim);
      font-size: .9rem;
      text-shadow: 1px 1px 2px #000c;
      opacity: 0; transition: opacity .4s ease;
      pointer-events: none;
    }

    .ticker-visible { opacity: 1 !important; }

    .hide { display: none !important; }

    /* Neon overlays */
    .overlay {
      position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;
    }
    .overlay .panel {
      background: rgba(24,24,24,.88);
      border: 2px solid var(--accent);
      box-shadow: 0 0 18px rgba(255,152,0,.35), inset 0 0 12px rgba(0,0,0,.3);
      padding: 20px 28px; border-radius: 14px; text-align: center;
    }
    .overlay .title {
      font-weight: 800; font-size: 2rem; letter-spacing: 2px;
      text-shadow: 0 0 8px rgba(255,152,0,.8), 0 0 18px rgba(255,152,0,.3);
    }
    .overlay .sub { color: var(--text-dim); margin-top: 8px; font-size: 1rem; }

    @media (max-width: 600px) {
      .menu-btn { font-size: 1rem; padding: 8px 10px; margin: 4px; }
      #floating-menu { min-width: 0; padding: 10px 6px; }
      #score, #highscore { font-size: .9rem; }
      .overlay .title { font-size: 1.6rem; }
    }
  </style>
</head>
<body>
  <div class="game-wrap">
    <div id="main-logo">PT by <span>PixelPlay</span></div>

    <div class="stage">
      <canvas id="game" width="480" height="320" aria-label="Portal Runner Game Canvas"></canvas>

      <!-- UI overlay -->
      <div id="ui" aria-hidden="true">
        <div id="score"></div>
        <div id="highscore"></div>
        <div id="track-info"></div>
      </div>

      <!-- Start / Pause / Game Over overlays (neon) -->
      <div id="pregame" class="overlay">
        <div class="panel">
          <div class="title">Get Ready…</div>
          <div class="sub">Tap / Click / Press Space to start</div>
          <div id="countdown" class="sub" style="margin-top:6px; font-size:1.1rem; color: var(--accent);"></div>
        </div>
      </div>

      <div id="paused" class="overlay hide">
        <div class="panel">
          <div class="title">Paused</div>
          <div class="sub"><span id="paused-score">Score: 0</span> • <span id="paused-high">High: 0</span></div>
          <div class="sub" style="margin-top:6px;">Press <b>P</b> or use the menu to resume</div>
        </div>
      </div>

      <div id="gameover" class="overlay hide">
        <div class="panel">
          <div class="title">Game Over</div>
          <div class="sub"><span id="over-score">Score: 0</span> • <span id="over-high">High: 0</span></div>
          <div class="sub" style="margin-top:6px;">Press <b>Restart</b> in menu or hit <b>R</b></div>
        </div>
      </div>
    </div>

    <!-- Floating menu -->
    <div id="floating-menu-btn" title="Menu"><div class="pixel-dot"></div></div>
    <div id="floating-menu" role="dialog" aria-label="Game Menu">
      <a href="index.html" class="menu-btn" id="menu-home" title="Home"><i class="fas fa-home"></i>Home</a>
      <button class="menu-btn" id="menu-restart" title="Restart"><i class="fas fa-redo"></i>Restart</button>
      <button class="menu-btn" id="menu-pause" title="Pause/Resume"><i class="fas fa-pause"></i>Pause</button>
      <button class="menu-btn" id="menu-music" title="Music"><i class="fas fa-music"></i>Music</button>
    </div>
  </div>

  <script>
    /* =====================
       GAME STATE & HELPERS
       ===================== */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // UI refs
    const scoreDiv = document.getElementById('score');
    const highDiv  = document.getElementById('highscore');
    const pregameEl = document.getElementById('pregame');
    const pausedEl  = document.getElementById('paused');
    const gameoverEl= document.getElementById('gameover');
    const pausedScore = document.getElementById('paused-score');
    const pausedHigh  = document.getElementById('paused-high');
    const overScore   = document.getElementById('over-score');
    const overHigh    = document.getElementById('over-high');
    const countdownEl = document.getElementById('countdown');
    const trackInfo   = document.getElementById('track-info');

    // Menu refs
    const floatingMenuBtn = document.getElementById('floating-menu-btn');
    const floatingMenu = document.getElementById('floating-menu');
    const menuRestart = document.getElementById('menu-restart');
    const menuPause = document.getElementById('menu-pause');
    const menuMusic = document.getElementById('menu-music');

    // LocalStorage highscore
    let highscore = Number(localStorage.getItem('portalHighscore') || 0);

    // Audio flags
    let userInteracted = false;
    let musicOn = true;

    // Game control
    const STATE = { PREGAME: 0, RUNNING: 1, PAUSED: 2, OVER: 3 };
    let state = STATE.PREGAME;

    // Physics / Player
    const gravity = 0.5;        // tuned for retro feel
    const jumpV = -7.8;         // base jump impulse
    const maxJumps = 3;         // multi-jump (double/triple)

    let player, particles, portals, platforms;
    let speed, t, score, worldOffset, jumpsAvailable;

    // Platform generation parameters ensuring safe landing
    const PLATFORM = {
      minW: 70, maxW: 140,
      minGap: 60, maxGap: 120,
      maxDeltaY: 60,
      baseY: H - 48,
      minY: 56, maxY: H - 40
    };

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function resetGame(){
      player = { x: W * 0.33, y: H * 0.5, vy: 0, w: 18, h: 18, onGround: false };
      particles = [];
      portals = [];
      platforms = [];
      speed = 2.4; t = 0; score = 0; worldOffset = 0;
      jumpsAvailable = maxJumps;
      state = STATE.PREGAME;

      // seed ground/platforms
      const startX = -50; let x = startX; let y = PLATFORM.baseY;
      for (let i=0;i<10;i++){
        const w = 200; // big starting runway
        platforms.push({ x, y, w, h: 14 });
        x += w + 40;
      }
      // add more procedural
      while (x < 2000){
        const w = rand(PLATFORM.minW, PLATFORM.maxW);
        const gap = rand(PLATFORM.minGap, PLATFORM.maxGap);
        const ny = clamp(y + rand(-PLATFORM.maxDeltaY, PLATFORM.maxDeltaY), PLATFORM.minY, PLATFORM.maxY);
        platforms.push({ x, y: ny, w, h: 14 });
        // occasional portal
        if (Math.random() < 0.35){
          const type = Math.random() < 0.5 ? 'tele' : 'score';
          portals.push({ x: x + w/2 - 10, y: ny - 22, w: 20, h: 20, type, active: true, phase: Math.random()*Math.PI*2 });
        }
        x += w + gap; y = ny;
      }
    }

    function rand(a,b){ return a + Math.random()*(b-a); }

    /* =====================
       AUDIO SYSTEM
       - One-shot SFX
       - Playlist with crossfade
       - Track ticker every 30s
       ===================== */
    // SFX
    const sfx = {
    jump: new Audio('audio/jump.mp3'),
    land: new Audio('audio/land.mp3'),
    pause: new Audio('game-music-walaki/death-scene.mp3'),
    over: new Audio('game-music-walaki/UG-KANYE.mp3'),
    start: new Audio('game-music-walaki/MIKASA.wavq')
    };
    Object.values(sfx).forEach(a => { a.volume = 0.35; });

    // Playlist
    const playlist = [
    { src: 'game-music-walaki/MIKASA.wav', title: 'MIKASA', artist: 'St. Walakii' },
    { src: 'game-music-walaki/UG-KANYE.mp3', title: 'UG KANYE', artist: 'St. Walakii' },
    { src: 'game-music-walaki/death-scene.mp3', title: 'DEATH SCENE', artist: 'St. Walakii' },
    { src: 'game-music-walaki/COD-GAME-THEME.mp3', title: 'COD', artist: 'St. Walakii' },
    { src: 'game-music-walaki/KUDOS-FAM.mp3', title: 'KUDOS FAM', artist: 'St. Walakii' },
    { src: 'game-music-walaki/MUNJU.wav', title: 'MUNJU', artist: 'St. Walakii' },
    { src: 'game-music-walaki/RAW.mp3', title: 'RAW', artist: 'St. Walakii' },
    { src: 'game-music-walaki/wait-what.mp3', title: 'WAIT WHAT!', artist: 'St. Walakii' }
    ];


    let musicA = null, musicB = null, activeMusic = 'A', currentTrack = 0, tickerTimer = 0, tickerVisible = false, lastTickerTime = 0;

    function initAudio(){
      if (musicA) return; // already
      musicA = new Audio(); musicB = new Audio();
      ;[musicA, musicB].forEach(a => { a.loop = false; a.volume = 0; a.preload = 'auto'; });
      loadTrackInto(musicA, currentTrack);
    }

    function loadTrackInto(el, idx){
      const track = playlist[idx % playlist.length];
      el.src = track.src;
      el.onended = () => nextTrack();
    }

    function playMusic(){
      if (!musicOn || !musicA) return; 
      const active = activeMusic === 'A' ? musicA : musicB;
      fadeTo(active, 0.6, 600);
      if (active.paused) active.play().catch(()=>{});
    }
    function stopMusic(){
      if (!musicA) return;
      fadeTo(musicA, 0, 400);
      fadeTo(musicB, 0, 400);
    }

    function nextTrack(){
      if (!musicA) return;
      const from = activeMusic === 'A' ? musicA : musicB;
      const to   = activeMusic === 'A' ? musicB : musicA;
      currentTrack = (currentTrack + 1) % playlist.length;
      loadTrackInto(to, currentTrack);
      to.currentTime = 0;
      if (musicOn) to.play().catch(()=>{});
      crossfade(from, to, 1200, 0.6);
      activeMusic = activeMusic === 'A' ? 'B' : 'A';
      showTrackTicker();
    }

    function crossfade(from, to, ms=1200, target=0.6){
      fadeTo(from, 0, ms); fadeTo(to, target, ms);
    }
    function fadeTo(audio, target, ms){
      const steps = 24; const dt = ms/steps; const dv = (target - audio.volume)/steps;
      let i=0; const iv = setInterval(()=>{ audio.volume = clamp(audio.volume + dv, 0, 1); if(++i>=steps){ clearInterval(iv); audio.volume = clamp(target,0,1);} }, dt);
    }

    function showTrackTicker(){
      const tr = playlist[currentTrack];
      trackInfo.textContent = `♪ ${tr.title} — ${tr.artist}`;
      trackInfo.classList.add('ticker-visible');
      tickerVisible = true; lastTickerTime = performance.now();
    }

    function maybeAutoTicker(){
      // show every 30 seconds for 5 seconds
      const now = performance.now();
      if (now - lastTickerTime > 30000){ showTrackTicker(); }
      if (tickerVisible && now - lastTickerTime > 5000){
        trackInfo.classList.remove('ticker-visible');
        tickerVisible = false;
      }
    }

    function playSfx(name){
      const a = sfx[name];
      if (!a || !userInteracted) return;
      try { a.currentTime = 0; a.play(); } catch(e){}
    }

    /* =====================
       INPUT
       ===================== */
    function firstInteraction(){
      if (userInteracted) return;
      userInteracted = true;
      initAudio();
      // start countdown (5 seconds)
      startCountdown(5);
      playSfx('start');
    }

    window.addEventListener('keydown', (e)=>{
      if (e.code === 'Space' || e.code === 'ArrowUp') { firstInteraction(); jump(); }
      if (e.code === 'KeyP') togglePause();
      if (e.code === 'KeyR') restartGame();
    });
    canvas.addEventListener('mousedown', () => { firstInteraction(); jump(); });
    canvas.addEventListener('touchstart', (e) => { firstInteraction(); jump(); }, {passive:true});

    /* =====================
       MENU
       ===================== */
    floatingMenuBtn.onclick = () => {
      floatingMenu.style.display = (floatingMenu.style.display === 'block') ? 'none' : 'block';
      if (floatingMenu.style.display === 'block') playSfx('pause');
    };
    document.body.addEventListener('click', (e) => {
      if (!floatingMenu.contains(e.target) && e.target !== floatingMenuBtn && !floatingMenuBtn.contains(e.target)) {
        floatingMenu.style.display = 'none';
      }
    }, true);

    menuRestart.onclick = () => { floatingMenu.style.display = 'none'; restartGame(); };
    menuPause.onclick = () => { floatingMenu.style.display = 'none'; togglePause(); };
    menuMusic.onclick = () => {
      musicOn = !musicOn;
      menuMusic.innerHTML = musicOn ? '<i class="fas fa-music"></i>Music' : '<i class="fas fa-volume-mute"></i>Muted';
      if (!userInteracted) return;
      if (musicOn) playMusic(); else stopMusic();
    };

    function togglePause(){
      if (state === STATE.RUNNING){ state = STATE.PAUSED; pausedEl.classList.remove('hide'); playSfx('pause'); }
      else if (state === STATE.PAUSED){ state = STATE.RUNNING; pausedEl.classList.add('hide'); }
    }

    function restartGame(){
      resetGame();
      pregameEl.classList.remove('hide');
      pausedEl.classList.add('hide');
      gameoverEl.classList.add('hide');
      floatingMenu.style.display = 'none';
      if (userInteracted) { startCountdown(3); playSfx('start'); }
    }

    /* =====================
       COUNTDOWN
       ===================== */
    let countdownTimer = null;
    function startCountdown(sec){
      state = STATE.PREGAME;
      pregameEl.classList.remove('hide');
      let n = sec; countdownEl.textContent = `Starting in ${n}…`;
      clearInterval(countdownTimer);
      countdownTimer = setInterval(()=>{
        n--; if (n>0) countdownEl.textContent = `Starting in ${n}…`;
        else { clearInterval(countdownTimer); countdownEl.textContent = 'GO!'; setTimeout(()=>{
          pregameEl.classList.add('hide');
          state = STATE.RUNNING;
          if (musicOn) playMusic();
        }, 350); }
      }, 1000);
    }

    /* =====================
       GAMEPLAY
       ===================== */
    function jump(){
      if (state !== STATE.RUNNING) return;
      if (jumpsAvailable > 0){
        player.vy = jumpV; // impulse
        jumpsAvailable--;
        spawnParticles(player.x + player.w/2, player.y + player.h, 10, '#ffffff');
        playSfx('jump');
      }
    }

    function update(){
      if (state !== STATE.RUNNING) return;
      t++;
      if (t % 320 === 0) speed += 0.08; // slow difficulty ramp

      // physics
      player.vy += gravity;
      player.y += player.vy;

      // world scroll (player x mostly fixed)
      worldOffset += speed;

      // platform collision (AABB underfoot)
      player.onGround = false;
      for (const pf of platforms){
        const relX = pf.x - worldOffset; // world -> screen
        if (player.x + player.w > relX && player.x < relX + pf.w){
          const pyTop = pf.y - player.h;
          if (player.y >= pyTop - 12 && player.y <= pyTop + 8 && player.vy >= 0){
            player.y = pyTop; player.vy = 0; player.onGround = true; jumpsAvailable = maxJumps; // reset jumps on land
          }
        }
      }

      if (player.onGround && Math.abs(player.vy) < 0.01 && t % 6 === 0){
        // tiny landing dust
        spawnParticles(player.x + player.w/2, player.y + player.h, 6, '#ffffff');
        playSfx('land');
      }

      // portals
      for (const pt of portals){
        if (!pt.active) continue;
        const relX = pt.x - worldOffset;
        if (rectsOverlap(player.x, player.y, player.w, player.h, relX, pt.y, pt.w, pt.h)){
          pt.active = false;
          if (pt.type === 'tele'){
            worldOffset += 420; // jump camera forward
            spawnPortalBurst(player.x + player.w/2, player.y + player.h/2, getColorTeleport());
            score += 15;
          } else { // score portal
            score += 25;
            spawnPortalBurst(player.x + player.w/2, player.y + player.h/2, getColorScore());
          }
        }
      }

      // cull old platforms/portals & extend ahead
      const rightEdgeWorld = worldOffset + W + 200;
      // remove way behind
      platforms = platforms.filter(p => p.x + p.w > worldOffset - 400);
      portals   = portals.filter(p => p.x + p.w > worldOffset - 400 && p.active);

      // extend
      let farthestX = platforms.reduce((m,p)=> Math.max(m, p.x + p.w), -Infinity);
      let lastY = platforms.reduce((m,p)=> (p.x + p.w === farthestX ? p.y : m), platforms[platforms.length-1]?.y || PLATFORM.baseY);
      while (farthestX < rightEdgeWorld){
        const w = rand(PLATFORM.minW, PLATFORM.maxW);
        const gap = rand(PLATFORM.minGap, PLATFORM.maxGap);
        const ny = clamp(lastY + rand(-PLATFORM.maxDeltaY, PLATFORM.maxDeltaY), PLATFORM.minY, PLATFORM.maxY);
        const nx = farthestX + gap;
        platforms.push({ x: nx, y: ny, w, h: 14 });
        // guaranteed safe-ish spacing because gap range + jump physics are tuned
        if (Math.random() < 0.33){
          const type = Math.random() < 0.5 ? 'tele' : 'score';
          portals.push({ x: nx + w/2 - 10, y: ny - 22, w: 20, h: 20, type, active: true, phase: Math.random()*Math.PI*2 });
        }
        farthestX = nx + w; lastY = ny;
      }

      // score ticks up over time
      score += 1;

      // particles update
      particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vy += p.g; p.life--; });
      particles = particles.filter(p => p.life > 0).slice(-240); // cap

      // death (fell off)
      if (player.y > H + 40){
        state = STATE.OVER; playSfx('over'); stopMusic();
        gameoverEl.classList.remove('hide');
      }
    }

    function rectsOverlap(x1,y1,w1,h1, x2,y2,w2,h2){
      return (x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2);
    }

    /* =====================
       VFX
       ===================== */
    function spawnParticles(x, y, n, color){
      for (let i=0;i<n;i++){
        const a = Math.random() * Math.PI * 2;
        const s = Math.random() * 1.8 + 0.4;
        particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, g: 0.06, color, life: 18 + (Math.random()*8|0) });
      }
    }
    function spawnPortalBurst(x, y, color){
      for (let i=0;i<22;i++){
        const a = (i/22) * Math.PI * 2;
        particles.push({ x, y, vx: Math.cos(a)*2.2, vy: Math.sin(a)*2.2, g: 0.02, color, life: 22 });
      }
    }

    function getColorTeleport(){ return '#00e5ff'; }
    function getColorScore(){ return '#b455ff'; }

    /* =====================
       DRAW
       ===================== */
    function draw(){
      // clear
      ctx.clearRect(0,0,W,H);

      // optional background portal loops
      drawBackgroundFx();

      // platforms
      for (const pf of platforms){
        const relX = pf.x - worldOffset;
        ctx.fillStyle = '#444';
        ctx.fillRect(relX, pf.y, pf.w, pf.h);
        // bevel line
        ctx.fillStyle = '#555';
        ctx.fillRect(relX, pf.y, pf.w, 3);
      }

      // portals
      for (const pt of portals){
        if (!pt.active) continue;
        const relX = pt.x - worldOffset;
        const cx = relX + pt.w/2, cy = pt.y + pt.h/2;
        const t = performance.now()/1000 + pt.phase;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.globalAlpha = 0.85;
        if (pt.type === 'tele'){
          // cyan rotating ring
          ctx.strokeStyle = getColorTeleport();
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.arc(0,0,12 + Math.sin(t*3)*1.6, 0, Math.PI*2);
          ctx.stroke();
          // inner dot swirl
          for (let i=0;i<6;i++){
            const a = t*3 + i;
            ctx.fillStyle = getColorTeleport();
            ctx.fillRect(Math.cos(a)*6 -1, Math.sin(a)*6 -1, 2, 2);
          }
        } else {
          // purple pulsing square
          ctx.strokeStyle = getColorScore();
          ctx.lineWidth = 2.5;
          const s = 18 + Math.sin(t*4)*3;
          ctx.strokeRect(-s/2, -s/2, s, s);
          // sparkles
          for (let i=0;i<4;i++){
            ctx.fillStyle = getColorScore();
            ctx.fillRect(Math.cos(t*5+i)*8 -1, Math.sin(t*5+i*1.3)*8 -1, 2, 2);
          }
        }
        ctx.restore();
      }

      // player (ball-style cube)
      ctx.fillStyle = '#fff';
      ctx.fillRect(player.x, player.y, player.w, player.h);

      // particles
      for (const p of particles){
        ctx.globalAlpha = Math.max(0, p.life/28);
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 3, 3);
        ctx.globalAlpha = 1;
      }

      // overlays are DOM; but draw subtle pause vignette if not running
      if (state === STATE.PAUSED || state === STATE.OVER){
        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      }

      // UI text
      scoreDiv.textContent = 'Score: ' + score;
      highscore = Math.max(highscore, score);
      localStorage.setItem('portalHighscore', String(highscore));
      highDiv.textContent  = 'High: ' + highscore;

      // update paused/gameover numbers
      pausedScore.textContent = 'Score: ' + score;
      pausedHigh.textContent  = 'High: ' + highscore;
      overScore.textContent   = 'Score: ' + score;
      overHigh.textContent    = 'High: ' + highscore;

      maybeAutoTicker();
    }

    function drawBackgroundFx(){
      // faint looping portal arcs in background for vibe
      const t = performance.now()/1000;
      ctx.save();
      ctx.globalAlpha = 0.08;
      for (let i=0;i<3;i++){
        const cx = (i*160 + (t*30)%160) % (W+60) - 30;
        const cy = 60 + i*80;
        ctx.strokeStyle = i%2? getColorTeleport() : getColorScore();
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cx, cy, 24 + Math.sin(t*2+i)*6, 0, Math.PI*2); ctx.stroke();
      }
      ctx.restore();
    }

    /* =====================
       LOOP
       ===================== */
    function loop(){
      if (state === STATE.RUNNING) update();
      draw();
      requestAnimationFrame(loop);
    }

    // bootstrap
    resetGame();
    loop();

    /* =====================
       ACCESSIBILITY
       ===================== */
    // Prevent space scrolling
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'Space' && e.target === document.body) e.preventDefault();
    });
  </script>
</body>
</html>